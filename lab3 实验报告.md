#                                  lab3  实验报告

## 一、实验内容

- 了解虚拟内存的Page Fault异常处理实现
- 了解页替换算法在操作系统中的实现
- 学会如何使用多级页表，处理缺页异常（Page Fault），实现页面置换算法。

## 二、实验过程

### 练习1：理解基于FIFO的页面替换算法（思考题）

描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？（为了方便同学们完成练习，所以实际上我们的项目代码和实验指导的还是略有不同，例如我们将FIFO页面置换算法头文件的大部分代码放在了`kern/mm/swap_fifo.c`文件中，这点请同学们注意）

1.分析swap_fifo.c的10个函数
（1）
static int
_fifo_init_mm(struct mm_struct *mm)
{     
     list_init(&pra_list_head);
     mm->sm_priv = &pra_list_head;
     //cprintf(" mm->sm_priv %x in fifo_init_mm\n",mm->sm_priv);
     return 0;
}
初始化FIFO链表头，建立一个FIFO链表存储进队列的页表

（2）
static int
_fifo_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
{
    list_entry_t *head=(list_entry_t*) mm->sm_priv;
    list_entry_t *entry=&(page->pra_page_link);

```
assert(entry != NULL && head != NULL);
//record the page access situlation

//(1)link the most recent arrival page at the back of the pra_list_head qeueue.
list_add(head, entry);
return 0;
```
}
取最近的一个页表，将其与FIFO链表进行添加操作，连接到链表最后面

（3）
static int
_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)
{
     list_entry_t *head=(list_entry_t*) mm->sm_priv;
         assert(head != NULL);
     assert(in_tick==0);
     /* Select the victim */
     //(1)  unlink the  earliest arrival page in front of pra_list_head qeueue
     //(2)  set the addr of addr of this page to ptr_page
    list_entry_t* entry = list_prev(head);
    if (entry != head) {
        list_del(entry);
        *ptr_page = le2page(entry, pra_page_link);
    } else {
        *ptr_page = NULL;
    }
    return 0;
}
将FIFO链表头的页表取出，并把它归还回可用页表链表中

（4）
assert()
若括号内的表达式为false，则中断程序的执行，用于确认必要条件。在换入换出中都有检查函数输入是否合法的作用

（5）
list_add()
函数接受两个参数，将前面的链表节点添加到后面的链表最后一位，在换入时它把最新页表添加进FIFO链表中

（6）
list_del()
函数接受一个参数，将这个节点从所在链表中删除，用于换出页表，从FIFO队列里删除。

（7）
le2page()
该函数接受两个参数，将节点从链表中找出，并返回它的地址以单独调用，在换出时它将换出的页表地址返回给函数。

（8）
list_prev()
该函数接受一个参数，返回它的前一个节点，在换出时用于记录FIFO链表头。

（9）
list_init()
该函数接受一个参数，将参数中的链表初始化为初始状态。

（10）
list_next()
该函数接受一个参数，将返回函数参数中节点的下一个节点。

### 练习2：深入理解不同分页模式的工作原理（思考题）

get_pte()函数（位于`kern/mm/pmm.c`）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。

- get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。

- 目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

  具体的页表层次（如sv32、sv39、sv48）取决于系统的虚拟内存管理策略，但基本的概念在不同的页表层次下是相似的。get_pte()函数中的两段代码都是在不同的页表层次中进行相似的操作。在不同的页表层次中，页表的结构是类似的，都包含了一个一级页表项（pdep1和pdep0）以及二级页表项（实际上是pte_t类型的指针）。因此，无论是在一级页表（sv32）、二级页表（sv39）还是三级页表（sv48）上执行操作，代码结构相似。

  查找和分配页表项通常是紧密相关的操作，可以在一个函数中组合执行以提高代码的可读性和性能。这样可以避免在两个不同的函数之间来回传递参数和重复执行类似的检查和操作。但拆开这两个功能可以更好地组织代码，提高可维护性，同时使代码更容易理解。

### 练习3：给未被映射的地址映射上物理页（需要编程）

补充完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。 请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。
- 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
- 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

页目录项（PDE）和页表项（PTE）在 ucore 实现页替换算法中有以下潜在用处：

- **访问位（Accessed Bit）和修改位（Dirty Bit）**：PDE 和 PTE 中通常会有表示页面是否被访问或修改的标志位。这些标志位可以用来实现某些页替换算法，例如 Clock 算法。当页面被访问或修改时，相应的标志位会被硬件自动设置，而页替换算法可以根据这些信息做出决策。

- **存在位（Present Bit）**：PDE 和 PTE 中的存在标志位可以表示相应的页或页表是否在物理内存中。如果一个页不在物理内存中（被换出），则可以清除此标志位，并在页表项中存储该页在磁盘上的位置信息。

- **权限位（Permission Bits）**：权限位（如读/写和用户/超级用户位）定义了对页面的访问权限。在进行页面替换时，这些信息可以帮助确定哪些页面可以被换出。

当ucore的缺页服务例程在执行过程中访问内存出现页访问异常时，硬件会执行以下步骤：

1. 保存当前的状态

   - 硬件会自动保存触发异常的当前状态，包括程序计数器、标志寄存器和其他相关寄存器的值。这样可以确保在异常处理完成后能够正确恢复到异常发生时的状态。
   - 在 [`trapentry.S`] 文件中，可以看到有一个 `SAVE_ALL` 宏，它保存了所有的寄存器状态。

2. 设置错误代码

   - 硬件会生成一个错误代码，该代码包含有关页访问异常的详细信息，例如引起异常的访问类型（读、写或执行）和引起异常的地址。
   - 在 [`trap.c`]文件中的 `exception_handler` 函数处理各种异常，包括页错误。在这个函数中，根据 `tf->cause` 的值，可以确定是哪种类型的页错误（例如，加载、存储等）。

3. <硬件>跳转到异常处理程序

   - 硬件会将控制权转交给预先配置的页访问异常处理程序。这通常是通过修改程序计数器来实现的，使其指向异常处理程序的入口地址，也就是trap.c。

     ```c
     //kern/trap/trap.c
     void trap(struct trapframe *tf) {
         ...
         case IRQN_PAGE_FAULT:
             pgfault_handler(tf);
             break;
         ...
     }
     ```

4. <内核>执行异常处理程序

   - 异常处理程序（也称为中断服务例程）会执行，它会根据错误代码分析异常的原因，并采取相应的措施，例如加载缺失的页面或更改页表项的权限。

     ```c
     //kern/mm/swap.c
     int swap_in(struct mm_struct *mm, uintptr_t addr, struct Page **pagep) {
         ...
     }
     
     //kern/mm/vmm.c
     int do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr) {
         ...
     }
     ```

5. <硬件>恢复状态并返回

   - 一旦异常处理程序完成，硬件会恢复之前保存的处理器状态，并将控制权返回给导致异常的指令的下一条指令，或者如果异常处理程序修改了程序计数器，则返回到一个新的地址。

     ```c
     //kern/trap/trap.c
     void trap(struct trapframe *tf) {
         ...
         if (tf->cause == IRQN_SYSCALL) {
             tf->epc += 4;
         }
         return;
     ```

`Page` 数据结构的全局变量数组中的每一项通常与物理页面相对应。而页目录项和页表项则是虚拟地址到物理地址的映射。`Page` 数据结构中的项通常会**包含与其对应的物理页面的管理和状态信息**。

- **对应关系**：每个 `Page` 结构通常会包含一个指向对应页表项的指针，或者包含足够的信息以便可以找到对应的页表项。这样，系统就可以根据 `Page` 结构快速找到和修改对应的页表项。
- **用途**：这种对应关系允许操作系统在管理物理内存时，可以方便地找到和修改虚拟地址到物理地址的映射，例如在页替换过程中。     

### 练习4：补充完成Clock页替换算法（需要编程）

通过之前的练习，相信大家对FIFO的页面替换算法有了更深入的了解，现在请在我们给出的框架上，填写代码，实现 Clock页替换算法（mm/swap_clock.c）。 请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 比较Clock页替换算法和FIFO算法的不同。

其设计实现过程如下：

1. **初始化**:
   - 函数 `_clock_init_mm` 中初始化了双向链表 `pra_list_head`，该链表用于跟踪当前内存中的所有页面。
   - `curr_ptr` 初始化为指向 `pra_list_head` 的指针，表示当前页面置换的位置从链表头开始。
   - mm 结构的私有成员指针指向 `pra_list_head`，以方便后续的页面置换算法操作。
2. **映射可置换的页面**:
   - 在 `_clock_map_swappable` 函数中，当一个新页面被映射到内存时，该页面会被添加到 `pra_list_head` 链表的末尾，并将其 `visited` 标志设置为1，表示该页面已经被访问。
3. **选择置换的受害者**:
   - 在 `_clock_swap_out_victim` 函数中，算法遍历 `pra_list_head` 链表，从当前指针 `curr_ptr` 开始，查找第一个其 `visited` 标志为0的页面（即未被访问的页面）。
   - 如果找到这样的页面，该页面将从链表中删除，并选择为要被置换出去的页面。
   - 如果页面的 `visited` 标志为1，表示该页面最近被访问过，因此将 `visited` 标志重置为0，并继续搜索下一个页面。
   - 如果在整个链表中都没有找到 `visited` 为0的页面，那么算法会再次从链表的开头开始搜索。

  **相同点**

  - Clock页替换算法和FIFO（First-In-First-Out）算法都是基于队列的置换算法，它们都按照页面进入内存的顺序来进行置换。
  - 在两种算法中，当需要替换页面时，它们都将选择最早进入内存的页面进行替换。

  **不同点**

  - Clock算法引入了一个"访问位"（R位），用于记录页面的访问状态。如果一个页面被访问，其R位会被设置为1，表示该页面有"第二次机会"。而FIFO算法不考虑页面的访问情况，只按照页面的进入顺序来置换页面。
  - Clock算法通过扫描环形缓冲区来查找一个具有"第二次机会"的页面，而FIFO算法只需简单地选择最早进入内存的页面进行替换。
  - 由于Clock算法考虑了页面的访问情况，因此它在某种程度上更智能化，有助于保留经常被访问的页面，从而减少了缺页率。而FIFO算法则没有这种智能化的机制。

### 练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）

如果我们采用”一个大页“ 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？

**优势和好处：**

1. **性能提升：** 使用一个大页可以减少页表的层次深度，从而减少了访问页表所需的内存访问次数。这可以提高内存访问的性能，特别是在大内存系统中。
2. **减少 TLB 缺失：** TLB（Translation Lookaside Buffer）是用于加速虚拟地址到物理地址转换的硬件缓存。使用大页可以减少TLB缺失，因为较大的内存区域可以映射到一个较少的TLB条目中，从而提高了地址转换的速度。
3. **降低页表维护开销：** 在分级页表中，每一级的页表需要维护更多的表项，这会增加页表的维护开销。使用一个大页可以减少页表中的表项数量，降低了页表的管理成本。

**坏处和风险：**

1. **内存浪费：** 使用大页可能会导致内存浪费。如果某个进程只需要一小部分大页映射的内存，那么其余部分内存将被浪费。这可能会导致内存利用率低下。
2. **不适用于小内存区域：** 大页适用于大块连续的内存，但在小内存区域上使用大页可能不切实际。如果内存碎片化严重或者内存分布不连续，使用大页可能会导致大量内存空间浪费。
3. **不灵活：** 使用大页会降低内存管理的灵活性。分级页表允许更精细的内存控制和映射，而大页通常是一种全局性的设置，难以适应不同应用程序或场景的需求。

### 扩展练习 Challenge：实现不考虑实现开销和效率的LRU页替换算法（需要编程）

challenge部分不是必做部分，不过在正确最后会酌情加分。需写出有详细的设计、分析和测试的实验报告。完成出色的可获得适当加分。

## 三、其他补充

- 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
- 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
- 列出你认为OS原理中很重要，但在实验中没有对应上的知识点


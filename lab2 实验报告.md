#                                  lab0.5  实验报告

## 一、实验内容

实验1主要讲解的是中断处理机制。操作系统是计算机系统的监管者，必须能对计算机系统状态的突发变化做出反应，这些系统状态可能是程序执行出现异常，或者是突发的外设请求。当计算机系统遇到突发情况时，不得不停止当前的正常工作，应急响应一下，这是需要操作系统来接管，并跳转到对应处理函数进行处理，处理结束后再回到原来的地方继续执行指令。这个过程就是中断处理过程。

## 二、实验过程

### 练习1：理解first-fit 连续物理内存分配算法（思考题）

first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。 请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 你的first fit算法是否有进一步的改进空间？

**default_init 函数：**

default_init 函数用于初始化`free_area`中的链表和计数器。它会调用 default_init_memmap 函数来初始化物理内存映射。

**default_init_memmap 函数：**

default_init_memmap 函数负责初初始化一个给定地址和大小的空闲块，即标记哪些物理页面是可用的，哪些已经被占用。这是通过遍历物理内存的方式来实现的。

**default_alloc_pages 函数：**

default_alloc_pages 函数是 first-fit 算法的实现。它遍历物理内存映射，查找第一个足够大的可用内存块，然后分配给请求的页面。
如果找到一个可用的内存块，它会将内存块标记为已分配，并返回一个指向分配的页面的指针。
如果没有足够大的可用内存块，分配失败，返回 NULL。

**default_free_pages 函数：**

default_free_pages 函数用于释放先前分配的页面。它会将页面标记为可用，以便以后的分配可以再次使用。

**物理内存分配过程如下：**

在系统初始化期间，default_init 函数被调用来初始化物理内存管理器。
default_init_memmap 函数被调用，遍历物理内存并标记可用的内存块。
当需要分配页面时，default_alloc_pages 被调用。它会遍历物理内存映射，找到第一个足够大的可用内存块，分配给请求的页面，并将其标记为已分配。
当不再需要这些页面时，default_free_pages 被调用，将页面标记为可用。

**流程总结：**

bootloader先调用entry.S中的**kern_entry**函数，为执行kern_init建立一个良好的C语言运行环境（设置堆栈），而且临时建立了一个段映射关系，为之后建立分页机制的过程做一个准备。SP指向在内核的内存空间里分配的栈（通过建立页表使得虚拟地址`0xFFFFFFFFC0200000`根据固定的偏移量经过页表的翻译恰好变成`0x80200000`，让`satp`指向这个页表），然后调用**kern_init**函数。

开始物理内存管理初始化：调用**pmm_init**函数完成物理内存的管理，在pmm.c中进行了初始化操作，其中**page_init()** 可以看到物理地址范围是：[KernelEnd, 0x88000000)，这个函数给这些管理物理内存的结构体做初始化，**pmm_manager**提供了分配页面，释放页面，查看当前空闲页面数的接口，在pmm_init()的**init_pmm_manager()**中进行了赋值，而具体接口的实现也就是页面分配算法在**default_pmm.c**中（例为First Fit:当需要分配页面时，它会从空闲页块链表中找到第一个适合大小的空闲页块，然后进行分配。当释放页面时，它会将释放的页面添加回链表，并在必要时合并相邻的空闲页块，以最大限度地减少内存碎片）。接着是执行中断和异常相关的初始化工作，即调用pic_init函数和idt_init函数等。

其他：satp记录了树状页表的根节点的物理地址，快表TLB记录了近期已完成的虚拟页号到物理页号的映射。如果刷新了satp或者页表项，需要用sfence.vma来刷新TLB。

### 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）

在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。 请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：

- 你的 Best-Fit 算法是否有进一步的改进空间？

**Best-Fit 和 First-Fit 的区别**：

1. **选择策略**:
   - **First-Fit**: First-Fit 算法选择第一个足够大的可用内存块来满足分配请求。它按顺序遍历可用内存块，选择第一个足够大的块。
   - **Best-Fit**: Best-Fit 算法在所有可用内存块中找到最适合请求大小的内存块，即选择最小的足够大的块。
2. **碎片问题**:
   - **First-Fit**: First-Fit 算法可能导致内存碎片问题。因为它通常选择第一个合适的块，较大的块可能会被分成两部分，其中一部分可能不再有用。
   - **Best-Fit**: Best-Fit 算法在理论上可以减少内存碎片问题，因为它选择了最适合请求大小的块。然而，它可能会导致更多的碎片，因为它倾向于选择较小的块，而较小的块通常更容易导致碎片。
3. **查找效率**:
   - **First-Fit**: First-Fit 算法在遍历可用内存块时，找到满足条件的块后就停止。这使得查找速度较快，但可能导致选择的块不是最佳的。
   - **Best-Fit**: Best-Fit 算法需要在所有可用内存块中找到最佳匹配，这可能需要更多的遍历，因此通常比 First-Fit 更慢。
4. **内存利用率**:
   - **First-Fit**: First-Fit 算法通常会导致一些内存碎片，降低了内存利用率。
   - **Best-Fit**: Best-Fit 算法在理论上可以提高内存利用率，因为它选择最接近请求大小的块。然而，它可能会导致更多的碎片，从而降低内存利用率。

**Best Fit 算法的实现思路**:

1. 维护一个可用内存块列表，通常以按大小升序排列。
2. 当有内存分配请求到达时，遍历可用内存块列表，找到第一个足够大的块以满足请求，并且大小最接近请求的块。
3. 如果找到适合的块，将其分配给请求的进程。
4. 如果找不到足够大的块，请求将被排队或者等待，直到有足够大的块可用。

**Best Fit 算法分配内存**：

- 当一个进程发出内存分配请求时，Best Fit 算法遍历可用内存块列表以找到最适合的块。
- 找到后，分配给进程，并将其标记为已分配。通常，分配后的块大小会减小以反映剩余可用内存。
- 分配后，更新可用内存块列表，可能需要将块分成两部分：一个用于分配，另一个保留未使用内存。

**Best Fit 算法释放内存**：

- 当进程释放内存时，将被释放的块标记为空闲。
- 接下来，通常会执行内存合并操作，即合并相邻的空闲块，以减少内存碎片。
- 更新可用内存块列表，以包括新的空闲块，确保列表保持有序。

### 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128…

- 参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

### 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

- 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

### 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）

- 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？

## 三、其他补充

- 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
- 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
- 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

